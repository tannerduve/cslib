/-
Some of this file was generated by Aristotle.
-/
import Mathlib.Data.Set.Basic
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.List.Basic
import Mathlib.Computability.Partrec
import Mathlib.MeasureTheory.MeasurableSpace.Defs
import Mathlib.Tactic.Ring

namespace AlgorithmicRandomness

-- Finite binary sequences
inductive BinSeq : Type where
  | Empty : BinSeq
  | Cons (b : Bool) (σ : BinSeq) : BinSeq
deriving Repr


-- Infinite binary sequences
abbrev InfBinSeq := Nat → Bool

open BinSeq

def BinSeq.length : BinSeq → Nat
  | Empty => 0
  | Cons _ σ => 1 + σ.length

lemma empty_length_zero : ∀ σ : BinSeq, σ.length = 0 ↔ σ = .Empty := by
  intro σ
  constructor <;> intro H1
  case mp =>
    cases σ
    case Empty =>
      aesop
    case Cons b τ =>
      simp [length] at H1
  case mpr =>
    aesop

def index (n : Nat) : BinSeq → Bool
  | .Empty => false
  | Cons b σ => match n with
    | 0 => b
    | Nat.succ k => index k σ

inductive initialSegment : BinSeq → InfBinSeq → Prop where
  | empty (X) : initialSegment Empty X
  | add (σ X) : initialSegment σ X →
      initialSegment (Cons (X (σ.length)) σ) X

-- def initialSegment' (τ : BinSeq) (X : InfBinSeq) : Prop :=
def initialSegment' : BinSeq → InfBinSeq → Prop :=
  fun τ X => ∃ n, n = τ.length ∧ ∀ k < n, X k = index k τ

abbrev extensions (σ : BinSeq) := { X : InfBinSeq | initialSegment σ X }

lemma nothing_covers_everything : ∀ X : InfBinSeq, X ∈ extensions BinSeq.Empty :=
  fun X => initialSegment.empty X



-- lemma nothing_covers_everything' : ∀ X : InfBinSeq, X ∈ extensions BinSeq.Empty :=
--   fun X => initialSegment' X


lemma initialSegmentEquiv {σ X} : initialSegment σ X ↔ initialSegment' σ X := by
  constructor <;> intro H
  case mp =>
    induction H
    case empty =>
      exists 0
      simp [length]
    case add τ X' IH IH' =>
      exists (τ.length + 1)
      constructor
      case left =>
        simp [length, add_comm]
      case right =>
        cases IH'
        case intro n IH' =>
          intro j H
          cases IH'
          case intro left right =>
            rw [left] at *
            sorry
  case mpr =>
    cases σ
    case Empty =>
      exact initialSegment.empty X
    case Cons b τ =>
      cases H
      case intro n H =>
        cases H
        case intro left right =>
          sorry

noncomputable section

-- Prefix relation on BinSeq
inductive pref : BinSeq → BinSeq → Prop where
  | empty_empty : pref Empty Empty
  | empty_seq {σ} : pref Empty σ
  | add {σ τ} : ∀ b : Bool, pref σ τ → pref (Cons b σ) (Cons b τ)

-- Prefix-free set
def prefix_free_set (S : Set BinSeq) : Prop :=
  ∀ σ ∈ S, ∀ τ ∈ S, σ ≠ τ → (¬ (pref σ τ))

def prefix_free_machine (f : BinSeq →. BinSeq) : Prop :=
  ∀ σ ∈ f.Dom, ∀ τ ∈ f.Dom, σ ≠ τ → (¬ (pref σ τ))

open scoped Classical in
instance : InfSet ℕ :=
  ⟨fun s ↦ if h : ∃ n, n ∈ s then @Nat.find (fun n ↦ n ∈ s) _ h else 0⟩

end



/-
Encoding of BinSeq to Nat.
-/


def BinSeq.toNat : BinSeq → Nat
  | .Empty => 0
  | .Cons b σ => 2 * σ.toNat + (if b then 2 else 1)

/-
Decoding of Nat to BinSeq.
-/

def BinSeq.ofNat : Nat → BinSeq
  | 0 => Empty
  | n + 1 =>
    if (n + 1) % 2 = 1 then Cons false (ofNat ((n + 1) / 2))
    else Cons true (ofNat ((n + 1) / 2 - 1))

/-
Round trip property: ofNat (toNat σ) = σ.
-/
-- open AlgorithmicRandomness

lemma BinSeq.ofNat_toNat (σ : BinSeq) :
                            BinSeq.ofNat (BinSeq.toNat σ) = σ := by
  revert σ;
  have h_ind : ∀ (n : Nat),
      BinSeq.ofNat n = BinSeq.ofNat n := by
    exact fun n => rfl;
  intro σ;
  induction σ using BinSeq.recOn;
  case Empty =>
    simp [BinSeq.toNat, BinSeq.ofNat];
  case Cons b σ IH =>
    -- By definition of `toNat`, we have `toNat (Cons b σ) = 2 * toNat σ + (if b then 2 else 1)`.
    have h_toNat : (Cons b σ).toNat = 2 * σ.toNat + (if b then 2 else 1) := by
      simp [toNat]
    by_cases hb : b;
    · have h_even : ofNat (2 * σ.toNat + 2) = Cons true (ofNat ((2 * σ.toNat + 2) / 2 - 1)) := by
        rw [BinSeq.ofNat];
        grind;
      simp_all +arith +decide;
    · have h_ofNat_odd : ofNat (2 * σ.toNat + 1) = Cons false (ofNat σ.toNat) := by
        rw [ ofNat ]
        grind
      aesop

/-
Round trip property: toNat (ofNat n) = n.
-/


set_option linter.style.longLine false

lemma BinSeq.toNat_ofNat (n : Nat) : BinSeq.toNat (BinSeq.ofNat n) = n := by
  have := @BinSeq.ofNat_toNat;
  -- By the hypothesis this, if σ.toNat = τ.toNat, then ofNat (σ.toNat) = ofNat (τ.toNat), which implies σ = τ.
  have h_inj : ∀ σ τ : BinSeq, σ.toNat = τ.toNat → σ = τ := by
    exact fun σ τ h => this σ ▸ this τ ▸ h ▸ rfl;
  contrapose! h_inj;
  -- Let's choose any two different binary sequences, say σ and τ, such that σ.toNat = τ.toNat.
  use BinSeq.Cons true BinSeq.Empty, BinSeq.Cons false BinSeq.Empty;
  simp +decide [ BinSeq.toNat ];
  exact h_inj ( by rw [ show BinSeq.toNat ( BinSeq.ofNat n ) = n from by
    exact Nat.strong_induction_on n fun n ih => by
      rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩;
      · unfold ofNat;
        rcases k with ( _ | k ) <;> simp +arith +decide [ * ];
        sorry
-- exact Eq.symm ( by erw [ show ( Cons true ( ofNat k ) ).toNat = 2 * ( ofNat k ).toNat + 2 by rfl ] ; linarith [ ih k ( by linarith ) ] );
      · unfold ofNat; simp +arith +decide [ ih ] ;
        norm_num [ Nat.add_div ];
        exact show 2 * ( ofNat k |> BinSeq.toNat ) + 1 = 2 * k + 1 from by rw [ ih k ( by grind ) ] ; ] )

/-
Checking Nat.Partrec
-/
#check Nat.Partrec

/-
Encodable instance for BinSeq.
-/
instance : Encodable BinSeq :=
  { encode := BinSeq.toNat
    decode := fun n => some (BinSeq.ofNat n)
    encodek := fun a => by simp [BinSeq.ofNat_toNat] }

/-
PRCode definition.
-/

inductive PRCode : Type
  | zero : PRCode
  | succ : PRCode
  | left : PRCode
  | right : PRCode
  | pair : PRCode → PRCode → PRCode
  | comp : PRCode → PRCode → PRCode
  | prec : PRCode → PRCode → PRCode
  | rfind : PRCode → PRCode

/-
PRCode encoding.
-/
def PRCode.encode : PRCode → Nat
  | zero => 0
  | succ => 1
  | left => 2
  | right => 3
  | pair c1 c2 => 4 + 5 * Nat.pair (encode c1) (encode c2)
  | comp c1 c2 => 4 + 5 * Nat.pair (encode c1) (encode c2) + 1
  | prec c1 c2 => 4 + 5 * Nat.pair (encode c1) (encode c2) + 2
  | rfind c => 4 + 5 * encode c + 3

/-
PRCode decoding.
-/
lemma helper : ∀ n: ℕ, n ≤ 5 * (n + 7) := by
  intro n; induction n <;> try aesop
  case succ k ih =>
    rw [mul_add, mul_add] at *
    simp at *
    have h : k ≤ (5 * k + 35) + 4 := by
      apply le_add_right ih
    assumption


def PRCode.decode : Nat → PRCode
  | 0 => zero
  | 1 => succ
  | 2 => left
  | 3 => right
  | n + 4 =>
    let m := (n - 4) / 5
    match (n - 4) % 5 with
    | 0 => pair (decode (Nat.unpair m).1) (decode (Nat.unpair m).2)
    | 1 => comp (decode (Nat.unpair m).1) (decode (Nat.unpair m).2)
    | 2 => prec (decode (Nat.unpair m).1) (decode (Nat.unpair m).2)
    | 3 => rfind (decode m)
    | _ => zero -- fallback
decreasing_by
rcases n with ( _ | _ | _ | _ | n ) <;> simp +arith +decide at *;
exact le_trans ( Nat.unpair_left_le _ ) ( Nat.div_le_of_le_mul <| helper n ); (
exact lt_of_le_of_lt ( Nat.unpair_right_le _ ) ( Nat.div_lt_of_lt_mul <| by omega )); (
omega)

def PRCode.eval : PRCode → Nat → Part Nat
  | zero, _ => Part.some 0
  | succ, n => Part.some (n + 1)
  | left, n => Part.some (Nat.unpair n).1
  | right, n => Part.some (Nat.unpair n).2
  | pair c1 c2, n =>
    (eval c1 n).bind fun x =>
    (eval c2 n).map fun y =>
    Nat.pair x y
  | comp c1 c2, n =>
    (eval c2 n).bind fun x =>
    eval c1 x
  | prec c1 c2, n =>
    let (x, y) := Nat.unpair n
    y.rec (eval c1 x) fun y_prev res_prev =>
      res_prev.bind fun res =>
      eval c2 (Nat.pair x (Nat.pair y_prev res))
  | rfind c, n =>
    Nat.rfind fun k =>
      (eval c (Nat.pair n k)).map fun res => res = 0

/-
Input parsing function.
-/

def parse (σ : BinSeq) : Option (Nat × BinSeq) :=
  match σ with
  | BinSeq.Empty => none
  | BinSeq.Cons false σ' => some (0, σ')
  | BinSeq.Cons true σ' =>
    match parse σ' with
    | some (n, p) => some (n + 1, p)
    | none => none

/-
Universal Machine U.
-/
noncomputable def U : BinSeq →. BinSeq := fun σ =>
  match parse σ with
  | some (n, p) =>
    let code := PRCode.decode n
    let rec loop (s : Nat) (input : BinSeq) : Part BinSeq :=
      match input with
      | BinSeq.Empty => Part.none
      | BinSeq.Cons b rest =>
        (PRCode.eval code (Nat.pair s (if b then 1 else 0))).bind fun res =>
          let status := (Nat.unpair res).1
          let data := (Nat.unpair res).2
          if status = 0 then
            loop data rest
          else
            if rest.length = 0 then
              Part.some (BinSeq.ofNat data)
            else
              Part.none
    loop 0 p
  | none => Part.none
/-
Machine from code.
-/
open AlgorithmicRandomness

def machine_from_code (c : PRCode) : BinSeq →. BinSeq := fun p =>
  let rec loop (s : Nat) (input : BinSeq) : Part BinSeq :=
    match input with
    | BinSeq.Empty => Part.none
    | BinSeq.Cons b rest =>
      (PRCode.eval c (Nat.pair s (if b then 1 else 0))).bind fun res =>
        let status := (Nat.unpair res).1
        let data := (Nat.unpair res).2
        if status = 0 then
          loop data rest
        else
          if rest.length = 0 then
            Part.some (BinSeq.ofNat data)
          else
            Part.none
  loop 0 p

/-
Prefix code parsing lemma.
-/
open AlgorithmicRandomness

def BinSeq.append : BinSeq → BinSeq → BinSeq
  | BinSeq.Empty, τ => τ
  | BinSeq.Cons b σ, τ => BinSeq.Cons b (append σ τ)

instance : Append BinSeq := ⟨BinSeq.append⟩

def prefix_code : Nat → BinSeq
  | 0 => BinSeq.Cons false BinSeq.Empty
  | n + 1 => BinSeq.Cons true (prefix_code n)

lemma parse_prefix_code (n : Nat) (p : BinSeq) :
  parse (prefix_code n ++ p) = some (n, p) := by
    -- The base case when n is 0 is not handled correctly. The parse function should return some (0, p) when the input is Empty ++ p.
    have h_base : parse (prefix_code 0 ++ p) = some (0, p) := by
      cases p <;> tauto;
    -- For the inductive step, assume that for some n, the parse function works for prefix_code n ++ p. We need to show it works for prefix_code (n+1) ++ p.
    have h_ind : ∀ n, parse (prefix_code n ++ p) = some (n, p) → parse (prefix_code (n + 1) ++ p) = some (n + 1, p) := by
      intros n ih;
      rw [ show prefix_code ( n + 1 ) = BinSeq.Cons true ( prefix_code n ) from rfl ];
      rw [ show BinSeq.Cons true ( prefix_code n ) ++ p = BinSeq.Cons true ( prefix_code n ++ p ) from rfl ];
      rw [ show parse ( BinSeq.Cons true ( prefix_code n ++ p ) ) = match parse ( prefix_code n ++ p ) with | some ( n, p ) => some ( n + 1, p ) | none => none from rfl ] ; aesop;
    exact Nat.recOn n h_base h_ind

/-
U simulation lemma.
-/
open AlgorithmicRandomness

lemma U_simulation (n : Nat) (p : BinSeq) :
  U (prefix_code n ++ p) = machine_from_code (PRCode.decode n) p := by
    -- Apply the parse_prefix_code lemma to rewrite the parse result.
    have h_parse : parse (prefix_code n ++ p) = some (n, p) := by
      exact?;
    unfold U machine_from_code;
    rw [ h_parse ];
    -- By definition of `U.loop` and `machine_from_code.loop`, we can show that they are equivalent by induction on the input `σ` and the state `s`.
    have h_loop_eq : ∀ (s : Nat) (σ : BinSeq), U.loop (PRCode.decode n) s σ = machine_from_code.loop (PRCode.decode n) s σ := by
      intros s σ; induction σ generalizing s; aesop;
      rename_i b σ ih;
      -- By definition of `U.loop` and `machine_from_code.loop`, we can show that they are equivalent by induction on the input `σ` and the state `s`. We'll use the induction hypothesis `ih` to simplify the goal.
      simp [U.loop, machine_from_code.loop, ih];
    exact h_loop_eq _ _

/-
Length of appended sequences.
-/
open AlgorithmicRandomness

lemma BinSeq.length_append (σ τ : BinSeq) :
  (BinSeq.append σ τ).length = σ.length + τ.length := by
  induction σ with
  | Empty => simp [BinSeq.append, BinSeq.length]
  | Cons b σ ih =>
    simp [BinSeq.append, BinSeq.length, ih]
    omega

/-
Checking Nat.unpair lemmas.
-/
#check Nat.unpair_left_le
#check Nat.unpair_right_le

/-
Corrected PRCode encoding.
-/
open AlgorithmicRandomness

def PRCode.encode' : PRCode → Nat
  | zero => 0
  | succ => 1
  | left => 2
  | right => 3
  | pair c1 c2 => 8 + 5 * Nat.pair (encode' c1) (encode' c2)
  | comp c1 c2 => 8 + 5 * Nat.pair (encode' c1) (encode' c2) + 1
  | prec c1 c2 => 8 + 5 * Nat.pair (encode' c1) (encode' c2) + 2
  | rfind c => 8 + 5 * encode' c + 3

/-
Debugging decode/encode.
-/
open AlgorithmicRandomness
#eval PRCode.decode 7
#eval PRCode.encode (PRCode.rfind PRCode.zero)

/-
Length of prefix code.
-/
open AlgorithmicRandomness

lemma length_prefix_code (n : Nat) : (prefix_code n).length = n + 1 := by
  induction n <;> simp +arith +decide [ *, BinSeq.length ];
  rw [ show prefix_code ( _ + 1 ) = BinSeq.Cons true ( prefix_code _ ) from rfl, BinSeq.length ] ; simp +arith +decide [ * ]

/-
C_plain_real definition.
-/
open AlgorithmicRandomness
noncomputable section

/-
decode (encode' c) = c
-/
open AlgorithmicRandomness

lemma PRCode.decode_encode' (c : PRCode) : PRCode.decode (PRCode.encode' c) = c := by
  -- By definition of `Nat.unpair`, we know that `Nat.unpair (Nat.pair x y) = (x, y)`.
  have h_unpair : ∀ x y : ℕ, Nat.unpair (Nat.pair x y) = (x, y) := by
    exact?;
  norm_num +zetaDelta at *;
  induction c <;> aesop;
  all_goals unfold decode; unfold PRCode.encode'; simp ( config := { decide := Bool.true } ) [ *, Nat.pair_unpair ] ;
  · rw [ show 8 + 5 * Nat.pair a.encode' a_1.encode' = 4 + 5 * Nat.pair a.encode' a_1.encode' + 4 by ring ] ; simp +arith +decide [ *, Nat.pair_unpair ] ;
  · rw [ show 8 + 5 * Nat.pair a.encode' a_1.encode' + 1 = 5 * ( Nat.pair a.encode' a_1.encode' + 1 ) + 4 by ring ] ; simp ( config := { decide := Bool.true } ) [ *, Nat.add_div ] ;
    norm_num [ show 5 * ( Nat.pair a.encode' a_1.encode' + 1 ) - 4 = 5 * ( Nat.pair a.encode' a_1.encode' ) + 1 by rw [ Nat.sub_eq_of_eq_add ] ; ring ] ; aesop;
    · norm_num [ Nat.add_div ] ; aesop;
    · norm_num [ Nat.add_div ] ; aesop;
  · simp +arith +decide [ Nat.add_mod, Nat.mul_mod, Nat.mod_eq_of_lt ];
    norm_num [ Nat.add_div ] ; aesop;
  · rw [ show 8 + 5 * a.encode' + 3 = ( 5 * a.encode' + 11 ) by ring ] ; simp +arith +decide [ Nat.add_mod, Nat.mul_mod, Nat.div_add_mod' ] ;
    norm_num [ Nat.add_div ] ; aesop

-- Prefix-free Kolmogorov complexity
abbrev producers (f : BinSeq →. BinSeq) (σ : BinSeq) :=
                  { n : ℕ | ∃ p : BinSeq, p.length = n ∧ f p = σ }


abbrev prefix_free_producers (σ : BinSeq) := { n | ∃ p : BinSeq, p.length = n ∧
                                             U p = σ ∧ prefix_free_set U.Dom }

def K (σ : BinSeq) [InfSet (prefix_free_producers σ)] [InfSet ℕ] : Nat :=
  sInf (prefix_free_producers σ)

end
end AlgorithmicRandomness
